/**
 * University of Illinois/NCSA
 * Open Source License
 *
 * Copyright (c) 2008, Board of Trustees-University of Illinois.
 * All rights reserved.
 *
 * Developed by:
 *
 * Automated Learning Group
 * National Center for Supercomputing Applications
 * http://www.seasr.org
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal with the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimers.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimers in the
 *    documentation and/or other materials provided with the distribution.
 *
 *  * Neither the names of Automated Learning Group, The National Center for
 *    Supercomputing Applications, or University of Illinois, nor the names of
 *    its contributors may be used to endorse or promote products derived from
 *    this Software without specific prior written permission.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * WITH THE SOFTWARE.
 */

package org.seasr.meandre.components.discovery.ruleassociation;

import gnu.trove.TIntArrayList;

import java.beans.PropertyVetoException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;
import java.util.logging.Level;

import org.meandre.annotations.Component;
import org.meandre.annotations.ComponentInput;
import org.meandre.annotations.ComponentOutput;
import org.meandre.annotations.ComponentProperty;
import org.meandre.core.ComponentContext;
import org.meandre.core.ComponentContextProperties;
import org.meandre.core.ComponentExecutionException;
import org.seasr.datatypes.datamining.table.Column;
import org.seasr.datatypes.datamining.table.basic.DoubleColumn;
import org.seasr.datatypes.datamining.table.basic.IntColumn;
import org.seasr.datatypes.datamining.table.basic.MutableTableImpl;
import org.seasr.datatypes.datamining.table.basic.TableImpl;
import org.seasr.meandre.components.abstracts.AbstractExecutableComponent;
import org.seasr.meandre.support.components.discovery.ruleassociation.FreqItemSet;
import org.seasr.meandre.support.components.discovery.ruleassociation.ItemSetInterface;
import org.seasr.meandre.support.components.discovery.ruleassociation.RuleTable;

/**
 * <p>Title:</p>
 *
 * <p>Description: This module works in conjunction with other modules
 * implementing the Apriori rule association algorithm to generate association
 * rules satisfying a minimum confidence threshold.</p>
 *
 * <p>Detailed Description: This module takes as input an <i>Item Sets</i>
 * object generated by the <i>Table To Item Sets</i> module, and <i>Frequent
 * Itemsets</i> generated by the <i>Apriori</i> module. From these inputs, it
 * develops a set of possible association rules, each with a single target item,
 * where an item consists of an [attribute,value] pair. For each possible rule,
 * this module computes the <i>Confidence</i> in the prediction, and accepts
 * those rules that meet a minimum confidence threshold specified via the
 * property editor.</p>
 *
 * <p>For a rule of the form Antecedent A implies Consequent C, the <i>
 * Confidence</i> is the percentage of examples in the original data that
 * contain A that also contain C. The formula to compute the confidence of the
 * rule A->C is:<br>
 * Confidence = ( (# of examples with A and C) / (# of examples with A ) ) *
 * 100.00</p>
 *
 * <p>Limitations: The <i>Apriori</i> and <i>Compute Confidence</i> modules
 * currently build rules with a single item in the consequent.</p>
 *
 * <p>Scalability: This module searches all the Items Sets to compute the
 * confidence for each Frequent Itemset. The module allocated memory for the
 * resulting Rule Table.</p>
 *
 * @author  $Author: mcgrath $
 * @author Boris Capitanu
 *
 * BC: Imported from d2k (ncsa.d2k.modules.core.discovery.ruleassociation.apriori.ComputeConfidence)
 *
 */

@Component(
		creator = "Boris Capitanu",
		description = "<p>This module works in conjunction with other modules implementing the Apriori "
	+ "rule association algorithm to generate association rules satisfying a minimum confidence "
	+ "threshold. "
	+

	"</p><p>Detailed Description: "
	+ "This module takes as input an <i>Item Sets</i> object generated by the <i>Table To Item Sets</i> "
	+ "module, and <i>Frequent Itemsets</i> generated by the <i>Apriori</i> or <i>FPGrowth</i> module.  "
	+ "From these inputs, it develops a set of possible association rules, each with a single "
	+ "target item, where an item consists of an [attribute,value] pair. "
	+ "For each possible rule, this module computes the <i>Confidence</i> in the prediction, "
	+ "and accepts those rules that meet a minimum confidence threshold specified via the "
	+ "property editor. "
	+

	"</p><p>"
	+ "For a rule of the form Antecedent A implies Consequent C, the <i>Confidence</i> is the percentage of "
	+ "examples in the original data that contain A that also contain C.   The "
	+ "formula to compute the confidence of the rule A->C is: <br>"
	+ " Confidence = ( (# of examples with A and C) / (# of examples with A ) ) * 100.00 "
	+

	"</p><p>Limitations: "
	+ "The <i>Apriori</i>, <i>FPGrowth</i>and <i>Compute Confidence</i> modules currently "
	+ "build rules with a single item in the consequent.  "
	+

	"</p><p>Scalability: "
	+ "This module searches all the Items Sets to compute the confidence for each Frequent Itemset. "
	+ "The module allocated memory for the resulting Rule Table. </p>",

	name = "Compute Confidence", tags = "rule association,confidence,discovery",
    baseURL="meandre://seasr.org/components/data-mining/"
)
public class ComputeConfidence extends AbstractExecutableComponent implements java.io.Serializable {

	@ComponentInput(description = "An Item Sets object containing the items of interest in the original data. "
		+ "This object is typically produced by a <i>Table To Item Sets</i> module.", name = "item_sets")
		final static String IN_ITEM_SETS = "item_sets";

	@ComponentInput(description = "The frequent itemsets found by an <i>Apriori</i> module.  These are the "
		+ "item combinations that frequently appear together in the original examples.", name = "freq_item_sets")
		final static String IN_FREQ_ITEM_SETS = "freq_item_sets";

	@ComponentOutput(description = "A representation of the association rules found and accepted by this module. "
		+ "This output is typically connected to a <i>Rule Visualization</i> module.", name = "rule_table")
		final static String OUT_RULE_TABLE = "rule_table";

	@ComponentProperty(description = "The percent of the examples containing a rule antecedent "
		+ "that must also contain the rule consequent before a potential association rule is accepted. "
		+ "This value must be greater than 0 and less than or equal to 100. ", name = "confidence", defaultValue = "70.0")
		final static String PROP_CONFIDENCE = "confidence";

	@ComponentProperty(description = "If this property is true, the module will report "
		+ "progress information to the console.", name = "verbose", defaultValue = "False")
		final static String PROP_VERBOSE = "verbose";

	//~ Static fields/initializers **********************************************

	/** Use serialVersionUID for interoperability. */
	static private final long serialVersionUID = 239828380100833138L;

	/** Label for head column. */
	static private final String HEAD = "Head";

	/** label for BODY column. */
	static private final String BODY = "Body";

	/** label for confidence column. */
	static private final String CONFIDENCE = "Confidence";

	/** label for support column. */
	static private final String SUPPORT = "Support";

	//~ Instance fields *********************************************************

	/** showProgress option.* */
	private boolean showProgress;

	/** confidence in the result. */
	double confidence;

	/**
	 * If this field exists, it contains the name of the item that is the
	 * preferred target.
	 */
	String targetItem = "";

	//~ Methods *****************************************************************

	/**
	 * Returns the confidence level in the results.
	 *
	 * @return double The confidence level in the results
	 */
	public double getConfidence() {
		return confidence;
	}

	/**
	 * Returns the value of the show progress property.
	 *
	 * @return boolean The value of the show progress flag.
	 */
	public boolean getShowProgress() {
		return showProgress;
	}

	/**
	 * Sets the confidence level.
	 *
	 * @param  newConfidence double The value for the confidence level.
	 *
	 * @throws PropertyVetoException if <code>newConfidence</code> is not in the
	 *                               range (0,100)
	 */
	public void setConfidence(double newConfidence)
	throws PropertyVetoException {

		if (newConfidence <= 0.0 || newConfidence > 100) {
			throw new PropertyVetoException(
					" Minimum Confidence % must be greater than 0 and less than or equal to 100.",
					null);
		}

		confidence = newConfidence;
	}

	/**
	 * Sets the value of the show progress property.
	 *
	 * @param newShowProgress boolean the value for the show progress bar.
	 */
	public void setShowProgress(boolean newShowProgress) {
		showProgress = newShowProgress;
	}

	@Override
	public void initializeCallBack(ComponentContextProperties ccp) throws Exception {
		showProgress = Boolean.parseBoolean(getPropertyOrDieTrying(PROP_VERBOSE, ccp));
		confidence = Double.parseDouble(getPropertyOrDieTrying(PROP_CONFIDENCE, ccp));
	}

	@Override
	public void executeCallBack(ComponentContext context) throws Exception {
		long startTime = System.currentTimeMillis();

		// pull the inputs.
		// ItemSets iss = (ItemSets) context.getDataComponentFromInput(DATA_INPUT_ITEM_SETS);
		ItemSetInterface iss =
			(ItemSetInterface) context.getDataComponentFromInput(IN_ITEM_SETS);

		int[][] fis = (int[][]) context.getDataComponentFromInput(IN_FREQ_ITEM_SETS);

		String[] items = iss.getItemsOrderedByFrequency();
		HashMap unique = iss.getUnique();

		// Init the counters.
		int numExamples = iss.getNumExamples();
		int numFis = fis.length;
		int numItems = items.length;
		int[] targetIndex = null;

		// So here we have a list of fields that we are going to
		// target, these are the outputs.
		String[] targets = iss.getTargetNames();
		Iterator keys = unique.keySet().iterator();
		// Iterator indxs = names.values().iterator();
		ArrayList list = new ArrayList();

		// for each of the attributes, see if the inputs include the attribute.
		while (keys.hasNext()) {
			String name = (String) keys.next();
			// int[] indx = (int[]) indxs.next();
			int[] indx = (int[]) unique.get(name);

			for (int i = 0; i < targets.length; i++) {

				if (name.startsWith(targets[i])) {
					list.add(indx);
				}
			}
		}

		// Put the indexes into the list.
		int size = list.size();

		if (size != 0) {
			targetIndex = new int[size];

			for (int i = 0; i < size; i++) {
				targetIndex[i] = ((int[]) list.get(i))[1];
			}
		}

		// get the bit map indicating what items were bought for each example.
		// boolean[][] itemFlags = iss.getItemFlags();
		Vector finalRules = new Vector();
		//     MutableIntegerArray[] documentMap = (MutableIntegerArray[]) iss.userData;

		console.fine("ComputeConfidence-> number of items: " + numItems);
		console.fine("ComputeConfidence-> number of frequent item sets: " + numFis);
		console.fine("ComputeConfidence-> number of examples: " + numExamples);

		///////////////////////////////////////
		//      Compute the confidence for each Rule.
		for (int i = 0; i < numFis; i++) {
			int[] currentRule = fis[i];
			int ruleLen = currentRule.length - 1;

			if (showProgress) {
				if ((i % 250) == 0) {
					console.info("Processed " + i + " rules out of " + numFis + ".");
				}
			}

			for (int j = 0; j < fis[i].length - 1; j++) {

				// Make a new rule array with one extra slot for the confidence
				int[] newRule = new int[fis[i].length + 1];

				for (int k = 0; k < j; k++) {
					newRule[k] = fis[i][k];
				}

				for (int k = j + 1; k < ruleLen; k++) {
					newRule[k - 1] = fis[i][k];
				}

				int mark = newRule[newRule.length - 3] = fis[i][j];
				newRule[newRule.length - 2] = fis[i][ruleLen]; // the support.

				if (targetIndex != null) {
					int tgts;

					for (tgts = 0; tgts < targetIndex.length; tgts++) {

						if (newRule[newRule.length - 3] == targetIndex[tgts]) {
							break;
						}
					}

					if (tgts == targetIndex.length) {
						continue;
					}
				}

				// the last entry in this array is the confidence that
				// given the first n-1 attributes the last attribute will
				// occur. To discover this, search for each example that
				// has the first n-1 elements, and check to see if it has
				// the nth.
				int total = 0;
				int hits = 0;
				int ruleLenLessOne = ruleLen - 1;

				for (int x = 0; x < numExamples; x++) {

					// First determine if the antecedents exist in the set.
					int y = 0;
					//boolean[] itf = itemFlags[x];
					int rowIdx = x;

					for (; y < ruleLenLessOne; y++) {
						int colIdx = newRule[y];
						//if (itf[newRule[y]] == false) {
						if (iss.getItemFlag(rowIdx,colIdx) == false) {
							break;
						}
					}

					// Did the antecedent exist in this set?
					if (y == ruleLenLessOne) {
						total++;
						int colIdx = mark;
						// if (itf[mark] == true) {
						if (iss.getItemFlag(rowIdx,colIdx) == true) {
							hits++;
						}
					}
				}

				// Here we will have the confidence.  Is it more than
				// minimum required?
				if ((((double) hits / (double) total) * 100.0) >= confidence) {

					// since we have an array of ints we put the confidence value in
					// there with some extra 0's so we can reintroduce precision
					// later
					newRule[newRule.length - 1] = (int) (((double) hits / (double) total) * 10000.00);
					finalRules.addElement(newRule);
					newRule = null;
				}
			} // end for

		} // end for

		if (console.getLevel().intValue() <= Level.FINE.intValue()) {
			for (int i = 0; i < finalRules.size(); i++) {
				int[] rule = (int[]) finalRules.elementAt(i);
				console.fine("ComputeConfidence -> " + items[rule[0]]);

				for (int k = 1; k < rule.length - 2; k++) {
					console.fine("," + items[rule[k]]);
				}

				console.fine("->" + rule[rule.length - 2] + "," + rule[rule.length - 1]);
			}
		}

		if (showProgress) {
			console.info(context.getExecutionInstanceID() +
					": A total of " +
					finalRules.size() +
					" rules were found that met the specified Minimum Confidence of " +
					getConfidence() + "%.");
		}

		if (finalRules.size() == 0) {
			throw new ComponentExecutionException(
					context.getExecutionInstanceID()
					+ ": No rules met the minimum confidence of "
					+ getConfidence() + "%.");
		}

		// Following code basically extracted from ConvertItemSetsToRuleTable and
		// folded into this module reusing datastructures we already have. May
		// still be some things that can be done better but am short on time.
		// There didn't seem to be any reason to keep them separate as the format
		// of the association rules previously formed here is not used elsewhere -
		// so, just transform into RuleTable directly.

		int numRules = finalRules.size();
		int[] head = new int[numRules];
		int[] body = new int[numRules];
		double[] ruleconfidence = new double[numRules];
		double[] rulesupport = new double[numRules];

		HashMap itemSets = new HashMap();

		for (int i = 0; i < numRules; i++) {
			int[] rule = (int[]) finalRules.elementAt(i);
			int numIf = rule.length - 3;
			int numThen = 1;

			int[] ifstmt = new int[numIf];
			int[] thenstmt = new int[numThen];

			for (int j = 0; j < numIf; j++) {
				ifstmt[j] = rule[j];
			}

			thenstmt[0] = rule[rule.length - 3];

			TIntArrayList ifitem = new TIntArrayList(ifstmt) {
				@Override
				public int hashCode() {
					StringBuffer sb = new StringBuffer();
					int[] ar = toNativeArray();
					Arrays.sort(ar);

					for (int i = 0; i < ar.length; i++) {
						sb.append(Integer.toString(ar[i]));

						if (i != ar.length - 1) {
							sb.append(",");
						}
					}

					return sb.toString().hashCode();
				}
			};

			TIntArrayList thenitem = new TIntArrayList(thenstmt) {
				@Override
				public int hashCode() {
					StringBuffer sb = new StringBuffer();
					int[] ar = toNativeArray();
					Arrays.sort(ar);

					for (int i = 0; i < ar.length; i++) {
						sb.append(Integer.toString(ar[i]));

						if (i != ar.length - 1) {
							sb.append(",");
						}
					}

					return sb.toString().hashCode();
				}
			};

			int ifidx;
			int thenidx;

			if (itemSets.containsKey(ifitem)) {
				ifidx = ((Integer) itemSets.get(ifitem)).intValue();
			} else {
				ifidx = itemSets.size();
				itemSets.put(ifitem, new Integer(ifidx));
			}

			if (itemSets.containsKey(thenitem)) {
				thenidx = ((Integer) itemSets.get(thenitem)).intValue();
			} else {
				thenidx = itemSets.size();
				itemSets.put(thenitem, new Integer(thenidx));
			}

			head[i] = ifidx;
			body[i] = thenidx;

			// in rule table both confidence and support are represented
			// as fractions.
			double conf = rule[rule.length - 1];
			conf /= 10000.0; // adjust decimal as earlier it was saved as int

			double supp = rule[rule.length - 2];
			supp /= numExamples;
			ruleconfidence[i] = conf;
			rulesupport[i] = supp;
		} // end for

		IntColumn headColumn = new IntColumn(head);
		headColumn.setLabel(HEAD);

		IntColumn bodyColumn = new IntColumn(body);
		bodyColumn.setLabel(BODY);

		DoubleColumn confidenceCol = new DoubleColumn(ruleconfidence);
		confidenceCol.setLabel(CONFIDENCE);

		DoubleColumn supportCol = new DoubleColumn(rulesupport);
		supportCol.setLabel(SUPPORT);

		Column[] c = { headColumn, bodyColumn, supportCol, confidenceCol };
		TableImpl ti = new MutableTableImpl(c);
		ArrayList al = new ArrayList(items.length);

		for (int i = 0; i < items.length; i++) {
			al.add(items[i].replace('^', '='));
		}

		Object[] freqSets = new Object[itemSets.size()];
		Iterator iter = itemSets.keySet().iterator();

		while (iter.hasNext()) {
			TIntArrayList itemset = (TIntArrayList) iter.next();
			int idx = ((Integer) itemSets.get(itemset)).intValue();
			FreqItemSet fris = new FreqItemSet();
			fris.items = itemset;
			fris.numberOfItems = itemset.size();

			/** !!!!!!!!!!!!!!!!!!!!!! **/
			fris.support = 0;
			freqSets[idx] = fris;
		}

		ArrayList allsets = new ArrayList(freqSets.length);

		for (int i = 0; i < freqSets.length; i++) {
			allsets.add(freqSets[i]);
		}

		RuleTable rt = new RuleTable(ti, 0, 0, numExamples, al, allsets);
		rt.sortByConfidence();
		context.pushDataComponentToOutput(OUT_RULE_TABLE, rt);

		/*File outputFile = new File("F:/D2K-update/d2k/irisrules_1.serial");

		    FileOutputStream fw;
		    try {
		        fw = new FileOutputStream(outputFile, false);
		    } catch (FileNotFoundException fnf) {
		        throw new RuntimeException("File could not be opened for writing,\n either file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for some other reason.",
		                                   fnf);
		    }
		    ObjectOutputStream out;
		    try {
		        out = new ObjectOutputStream(fw);
		    } catch (IOException ioe) {
		        throw new RuntimeException(
		                "I/O error occured while writing stream header", ioe);
		    }
		    try {
		        out.writeObject(rt);
		        out.close();
		    } catch (NotSerializableException nse) {
		        nse.printStackTrace();
		        throw new RuntimeException(
		                "The input Object is not Serializable and can't be written to a file",
		                nse);
		    } catch (IOException ioe) {
		        throw new RuntimeException("I/O error occured while writing out Object",
		                                   ioe);
		    }

		    File inputFile = new File("F:/D2K-update/d2k/irisrules_1.serial");

		    FileInputStream fin;
		    try {
		        fin = new FileInputStream(inputFile);
		    } catch (FileNotFoundException fnf) {
		        throw new RuntimeException("File could not be opened for reading,\n either file exists but is a directory rather than a regular file, does not exist, or cannot be opened for some other reason.",
		                                   fnf);
		    }
		    ObjectInputStream in;
		    try {
		        in = new ObjectInputStream(fin);
		    } catch (IOException ioe) {
		        throw new RuntimeException(
		                "I/O error occured while reading stream header", ioe);
		    }

		    Object theOb;
		    try {
		        theOb = in.readObject();
		    } catch (ClassNotFoundException cnf) {
		        throw new RuntimeException(
		                "The class of the Serialized Object could not be found!", cnf);
		    } catch (InvalidClassException ice) {
		        ice.printStackTrace();
		        System.out.println("classname = " + ice.classname + "\n" +
		                           "message = " + ice.getMessage() + "\n");
		        throw new RuntimeException(
		                "Something is wrong with a class used by Serialization (wrong JRE version?)!",
		                ice);
		    } catch (StreamCorruptedException sce) {
		        throw new RuntimeException(
		                "Control information in the stream is inconsistent!", sce);
		    } catch (IOException ioe) {
		        throw new RuntimeException("I/O error occured while reading in Object",
		                                   ioe);
		    }*/

		/*if (showProgress || debug) {
		        _logger.setDebugLoggingLevel();//temp set to debug
		        _logger.debug(context.getExecutionInstanceID() +
		                ": Elapsed Wallclock time was " +
		                (System.currentTimeMillis() - startTime) / 1000.00 +
		        " Seconds");
		        _logger.resetLoggingLevel();//re-set level to original level

		    }*/
	}

	@Override
	public void disposeCallBack(ComponentContextProperties ccp) throws Exception {
	}
}
