/**
 * University of Illinois/NCSA
 * Open Source License
 *
 * Copyright (c) 2008, Board of Trustees-University of Illinois.
 * All rights reserved.
 *
 * Developed by:
 *
 * Automated Learning Group
 * National Center for Supercomputing Applications
 * http://www.seasr.org
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal with the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimers.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimers in the
 *    documentation and/or other materials provided with the distribution.
 *
 *  * Neither the names of Automated Learning Group, The National Center for
 *    Supercomputing Applications, or University of Illinois, nor the names of
 *    its contributors may be used to endorse or promote products derived from
 *    this Software without specific prior written permission.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * WITH THE SOFTWARE.
 */

package org.meandre.components.discovery.ruleassociation.fptree;
//==============

//==============
import gnu.trove.TIntHashSet;
import gnu.trove.TIntIntHashMap;
import gnu.trove.TIntObjectHashMap;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;

import org.meandre.annotations.Component;
import org.meandre.annotations.ComponentInput;
import org.meandre.annotations.ComponentOutput;
import org.meandre.annotations.Component.Licenses;
import org.meandre.core.ComponentContext;
import org.meandre.core.ComponentContextProperties;
import org.seasr.meandre.components.abstracts.AbstractExecutableComponent;
import org.seasr.meandre.support.components.discovery.ruleassociation.fpgrowth.FPPattern;
import org.seasr.meandre.support.components.discovery.ruleassociation.fpgrowth.FPProb;
import org.seasr.meandre.support.components.discovery.ruleassociation.fpgrowth.FPSparse;
import org.seasr.meandre.support.components.discovery.ruleassociation.fpgrowth.FPTreeNode;
import org.seasr.meandre.support.components.discovery.ruleassociation.fpgrowth.FeatureTableElement;

/**
 * @author Lily Dong
 * @author Boris Capitanu
 */

@Component(
        creator = "Lily Dong",
        description = "<p>Overview: " +
                      "This module implements the CLOSET algorithm to generate closed frequent itemsets consisting of " +
                      "items that occur in a sufficient number of examples to satisfy the minimum support criteria. " +
                      "</p><p>Detailed Description: " +
                      "This module takes an <i>FPProb</i> object that has been generated by a <i>Large Item Table Generator</i> " +
                      "module and uses the CLOSET algorithm to find " +
                      "the combinations of items that satisfy a minimum support criteria. " +
                      "An item is an [attribute,value] pair that occurs in the set of examples being mined. " +
                      "The user controls the support criteria via the <iSupport</i> property of LargeItemTableGenerator that specifies the " +
                      "number of all examples that must contain a given combination of items " +
                      "before that combination is included in the generated output. " +
                      "Each combination of items that satisfies the <i>Minimum Support %</i> is called " +
                      "a <i>Frequent Itemset</i>. The CLOSET algorithm further restricts the itemsets returned " +
                      "by returning only the closed sets. (see Han 2000)" +
                      "</p><p>References: " +
                      "For more information on the CLOSET frequent pattern mining algorithm, see &quot; CLOSET: An Efficient Algorithm for Mining Frequent Closed Itemsets " +
                      "&quot;, Jian Pei, Jiawei Han, Runying Mao, 2000. " +
                      "</p><p>Data Type Restrictions: " +
                      "While this module can operate on attributes of any datatype, in practice it is usually infeasible " +
                      "to use it with continuous-valued attributes.   The module considers each [attribute,value] pair that occurs " +
                      "in the examples individually when building the frequent itemsets.  Continuous attributes (and categorical " +
                      "attributes with a large number of values) are less likely to meet the Minimum Support requirements " +
                      "and can result in unacceptably long execution time.",
        name = "CLOSET",
        tags = "closet, frequent itemsets, itemsets",
        rights = Licenses.UofINCSA,
        baseURL = "meandre://seasr.org/components/"
)
public class CLOSET extends AbstractExecutableComponent {

    //------------------------------ INPUTS ------------------------------------------------------

    @ComponentInput(
            description = "The input parameters encapsulated in an FPProb object.",
            name= "fp_prob"
    )
    protected static final String IN_FPPROB = "fp_prob";

    //------------------------------ OUTPUTS -----------------------------------------------------

    @ComponentOutput(
            description = "List of all closed frequent patterns discovered.",
            name = "patterns"
    )
    protected static final String OUT_PATTERNS = "patterns";

    //--------------------------------------------------------------------------------------------


    private ArrayList<FPPattern> _patterns;
    private TIntObjectHashMap<TIntObjectHashMap<ArrayList<FPTreeNode>>> _closhash;
    private TIntIntHashMap _supports;
    private FPTreeNode _csetroot;


    //--------------------------------------------------------------------------------------------

    @Override
    public void initializeCallBack(ComponentContextProperties ccp) throws Exception {
        _patterns = null;
        _closhash = null;
        _supports = null;
        _csetroot = null;
    }

    @Override
    public void executeCallBack(ComponentContext cc) throws Exception {
        FPProb prob = (FPProb) cc.getDataComponentFromInput(IN_FPPROB);
        _patterns = new ArrayList<FPPattern>();
        _closhash = new TIntObjectHashMap<TIntObjectHashMap<ArrayList<FPTreeNode>>>();

        //sets up the result tree
        getSupports(prob);

        prob.setConditionalSupport(Integer.MAX_VALUE);
        FPProcess(prob);

        cc.pushDataComponentToOutput(OUT_PATTERNS, _patterns);
    }

    @Override
    public void disposeCallBack(ComponentContextProperties ccp) throws Exception {
        _patterns = null;
        _closhash = null;
        _supports = null;
        _csetroot = null;
    }

    //--------------------------------------------------------------------------------------------

    private void getSupports(FPProb prob) {
        TreeSet<FeatureTableElement> tfeats = new TreeSet<FeatureTableElement>(new FeatureComparator());
        //initialize the root for the result tree
        _csetroot = new FPTreeNode(-1, null, -1, -1);

        if (_supports == null)
            _supports = new TIntIntHashMap();

        FPSparse tab = prob.getTable();
        int support = prob.getSupport();

        for (int i = 0, n = tab.getNumColumns(); i < n; i++) {
            int coltot = tab.getColumnTots(i);
            int lbl = tab.getLabel(i);
            if (coltot > support)
                tfeats.add(new FeatureTableElement(lbl, coltot, i));
        }

        int i = 0;
        for (Iterator<FeatureTableElement> it = tfeats.iterator(); it.hasNext(); i++)
            _supports.put(it.next().getLabel(), i);
    }

    private boolean isSubsetOfClosedItemsetOfSameSupport(FPPattern patt) {
        int elt = 0;
        int min = Integer.MAX_VALUE;

        for (gnu.trove.TIntIterator it = patt.getPattern(); it.hasNext(); ) {
            int tst = it.next();
            int icmp = _supports.get(tst);
            if (icmp < min){
                min = icmp;
                elt = tst;
            }
        }

        TIntObjectHashMap<ArrayList<FPTreeNode>> m = _closhash.get(elt);
        if (m == null) return false;

        ArrayList<FPTreeNode> l = m.get(patt.getSupport());
        if (l == null) return false;

        for (int i = 0, n = l.size(); i < n; i++) {
            FPTreeNode node = l.get(i);

            if (node.getPosition() < patt.getSize()) continue;

            if (node.getPosition() == patt.getSize()) {
                if (node.getNumChildren() == 0) continue;

                Object[] children = node.getChildren().getValues();

                boolean okay = false;
                for (int j = 0, k = children.length; j < k; j++)
                    if (((FPTreeNode)children[j]).getCount() == patt.getSupport())
                        okay = true;

                if (!okay) continue;
            }

            //collect values into array
            node = node.getParent();

            TIntHashSet compset = new TIntHashSet();
            compset.add(node.getLabel());

            while (!node.isRoot()) {
                compset.add(node.getLabel());
                node = node.getParent();
            }

            if (compset.containsAll(patt.getPatternArray()))
                return true;
        }

        return false;
    }

    private void addPatternToLookup(FPPattern patt) {
        int patsupp = patt.getSupport();
        TreeSet<FeatureTableElement> tfeats = new TreeSet<FeatureTableElement>(new FeatureComparator());

        for (gnu.trove.TIntIterator it = patt.getPattern(); it.hasNext(); ) {
            int fte = it.next();
            tfeats.add(new FeatureTableElement(fte, _supports.get(fte), 0));
        }

        FPTreeNode current = _csetroot;
        int j = 0;
        for (Iterator<FeatureTableElement> it = tfeats.iterator(); it.hasNext(); j++) {
            FeatureTableElement fte = it.next();
            FPTreeNode next = current.getChild(fte.getLabel());

            if (next == null) {
                next = new FPTreeNode(fte.getLabel(), current, patsupp, j);
                //update double hash
                TIntObjectHashMap<ArrayList<FPTreeNode>> suppmap = _closhash.get(fte.getLabel());
                ArrayList<FPTreeNode> ndarr = null;

                if (suppmap == null) {
                    suppmap = new TIntObjectHashMap<ArrayList<FPTreeNode>>();
                    ndarr = new ArrayList<FPTreeNode>();
                    ndarr.add(next);
                    suppmap.put(patsupp, ndarr);
                    _closhash.put(fte.getLabel(), suppmap);
                }
                else {
                    ndarr = suppmap.get(patsupp);
                    if (ndarr == null) {
                        ndarr = new ArrayList<FPTreeNode>();
                        ndarr.add(next);
                        suppmap.put(patsupp, ndarr);
                    }
                    else {
                        ndarr.add(next);
                    }
                }

                current.addChild(next);
            }
            else {
                if (next.getCount() < patsupp) {
                    int oldsupp = next.getCount();
                    next.setCount(patsupp);

                    //add new support value for this node
                    TIntObjectHashMap<ArrayList<FPTreeNode>> suppmap = _closhash.get(fte.getLabel());
                    ArrayList<FPTreeNode> ndarr = null;
                    ndarr = suppmap.get(patsupp);

                    if (ndarr == null) {
                        ndarr = new ArrayList<FPTreeNode>();
                        ndarr.add(next);
                        suppmap.put(patsupp, ndarr);
                    }
                    else {
                        ndarr.add(next);
                    }
                    //remove old support reference
                    ndarr = suppmap.get(oldsupp);
                    ndarr.remove(next);
                }
            }
            current = next;
        }
    }

    private void FPProcess(FPProb prob) {
        FPTreeNode root = new FPTreeNode(-1, null, -1, -1);
        int[] alpha = prob.getAlpha();
        FPSparse tab = prob.getTable();
        int support = prob.getSupport();
        int maxSupport = prob.getMaxSupport();
        //Build header table
        TreeSet<FeatureTableElement> tfeats = new TreeSet<FeatureTableElement>(new FeatureComparator());
        ArrayList<FeatureTableElement> tfeats2 = new ArrayList<FeatureTableElement>();

        //pattern for Optimization 2 (see CLOSET paper)
        FPPattern everytrans = new FPPattern(alpha, prob.getConditionalSupport());;
        for (int i = 0, n = tab.getNumColumns(); i < n; i++) {
            int coltot = tab.getColumnTots(i);
            if ((coltot >= support) && (coltot <= maxSupport)) {
                if (coltot == prob.getConditionalSupport()) {
                    //Optimization 2
                    everytrans.addPatternElt(tab.getLabel(i));
                    tfeats2.add(new FeatureTableElement(tab.getLabel(i), coltot, i));
                } else {
                    tfeats.add(new FeatureTableElement(tab.getLabel(i), coltot, i));
                }
            }
        }

        //Optimization 2
        if (everytrans.getSize() > 0) {
            boolean go = true;
            if ((!isSubsetOfClosedItemsetOfSameSupport(everytrans))) {
                if (everytrans.getSupport() >= support){
                    _patterns.add(everytrans);
                    addPatternToLookup(everytrans);
                    go = false;
                }
            } else {
                if ((tfeats2.size() > 0) && go)
                    tfeats.addAll(tfeats2);
            }
        }

        //trim the list
        ArrayList<FeatureTableElement> headers = new ArrayList<FeatureTableElement>();
        for (Iterator<FeatureTableElement> it = tfeats.iterator(); it.hasNext();) {
            FeatureTableElement fte = it.next();
            headers.add(fte);
        }

        int leafcnt = 0;

        //build the FPTree
        for (int i = 0, n = tab.getNumRows(); i < n; i++) {
            FPTreeNode current = root;
            for (int j = 0, m = headers.size(); j < m; j++) {
                FeatureTableElement fte = headers.get(j);
                int val = tab.getInt(i, fte.getPosition());
                if (val > 0) {
                    FPTreeNode next = current.getChild(fte.getLabel());
                    if (next == null) {
                        if (current.isRoot() || (current.getNumChildren() > 0)) {
                            leafcnt++;
                        }
                        next = new FPTreeNode(fte.getLabel(), current, val, j);
                        fte.addPointer(next);
                        current.addChild(next);
                    }
                    else {
                        next.inc(val);
                    }
                    current = next;
                }
            }
        }

        //========================================================================
        // BEGIN FPGROWTH ========================================================
        //========================================================================
        /**
         * If the tree is null, return
         */
        if (leafcnt == 0) return;

        ArrayList<FeatureTableElement> removes = new ArrayList<FeatureTableElement>();
        for (int a = headers.size() - 1; a >= 0; a--) {
            FeatureTableElement fte = headers.get(a);
            List<FPTreeNode> ptrs = fte.getPointers();
            if (ptrs.size() == 1) {
                FPTreeNode nd = ptrs.get(0);
                if ((nd.getNumChildren() == 0) || (nd.getNumChildren() > 1) ||
                        (((FPTreeNode)(nd.getChildren().getValues())[0]).getCount() < nd.getCount())){
                    boolean okay = true;
                    FPTreeNode nnd = nd;
                    FPPattern newpatt = new FPPattern(alpha, nd.getCount()/*0*/);
                    while (true){
                        nnd = nnd.getParent();
                        if (nnd.getNumChildren() > 1){
                            okay = false;
                            break;
                        }
                        if (nnd.isRoot()){
                            break;
                        }
                        newpatt.addPatternElt(nnd.getLabel());
                    }
                    if (okay){
                        newpatt.addPatternElt(nd.getLabel());
                        if (nd.getCount() >= support){
                            if (!isSubsetOfClosedItemsetOfSameSupport(newpatt)){
                                _patterns.add(newpatt);
                                this.addPatternToLookup(newpatt);
                                //System.out.println("Added pattern .... ");
                                //newpatt.setSupport(nd.getCount());
                                removes.add(fte);
                            }
                        }
                    }
                }
            }
        }

        /**
         * else, take each feature from header table (in reverse support order) and
         * output that feature|union alpha as a pattern, create a new patterns DB,
         * create new FPProb, and finally call FPProcess.
         */
        for (int a = headers.size() - 1; a >= 0; a--) {
            FeatureTableElement fte = headers.get(a);
            if (removes.contains(fte)) continue;

            List<FPTreeNode> ptrs = fte.getPointers();
            //add the entry in the table union alpha
            FPPattern pat = new FPPattern(alpha, fte.getCnt());
            pat.addPatternElt(fte.getLabel());

            if (isSubsetOfClosedItemsetOfSameSupport(pat)) continue;

            FPSparse otab = new FPSparse(headers.size());
            int[] colmap = new int[headers.size()];
            int cind = 1;
            //create new pattern DB
            int cnter = 0;
            for (int i2 = 0, n2 = ptrs.size(); i2 < n2; i2++) {
                FPTreeNode node = ptrs.get(i2);
                List<FPTreeNode> l = this.getPath(node);
                for (int i3 = 0, n3 = l.size(); i3 < n3; i3++) {
                    FPTreeNode node2 = l.get(i3);
                    if (colmap[node2.getPosition()] == 0) {
                        otab.addColumn((headers.get(node2.getPosition())).getLabel());
                        colmap[node2.getPosition()] = cind;
                        cind++;
                    }
                    otab.setInt(node.getCount(), cnter, colmap[node2.getPosition()] - 1);
                }

                if (l.size() > 0)
                    cnter++;
            }

            //build a new prob and submit it for processing
            int[] newalpha = new int[alpha.length + 1];
            System.arraycopy(alpha, 0, newalpha, 0, alpha.length);
            newalpha[newalpha.length - 1] = fte.getLabel();
            FPProb newprob = new FPProb(otab, newalpha, support);
            newprob.setConditionalSupport(fte.getCnt());
            FPProcess(newprob);
        }
    }

    private List<FPTreeNode> getPath(FPTreeNode node) {
        ArrayList<FPTreeNode> list = new ArrayList<FPTreeNode>();
        if (node.isRoot()) return list;

        node = node.getParent();
        while (true) {
            if (node.isRoot())
                return  list;

            list.add(node);
            node = node.getParent();
        }
    }

    //=============
    // Inner Class
    //=============
    protected class FeatureComparator implements java.util.Comparator<FeatureTableElement> {

        public int compare(FeatureTableElement fte1, FeatureTableElement fte2) {
            if (fte1.getCnt() == fte2.getCnt()) {
                if (fte1.getLabel() > fte2.getLabel()) {
                    return  1;
                }
                else if (fte1.getLabel() < fte2.getLabel()) {
                    return  -1;
                }
                else {
                    console.severe("The features are identical - this should never happen!");
                    return  0;
                }
            }
            else if (fte1.getCnt() > fte2.getCnt()) {
                return  -1;
            }
            else {
                return  1;
            }
        }
    }

    // compare two patterns based on support
    // added on May 28, 2009
    protected class FPPatternComparator implements Comparator<FPPattern> {
        public int compare(FPPattern p1, FPPattern p2) {
            int s1 = p1.getSupport(),
            s2 = p2.getSupport();
            return new Integer(s2).compareTo(new Integer(s1));
        }
    }
}




